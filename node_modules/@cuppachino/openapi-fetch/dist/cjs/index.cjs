"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiError = exports.arrayRequestBody = exports.Fetcher = void 0;
const never = Symbol();
const sendBody = (method) => method === 'post' ||
    method === 'put' ||
    method === 'patch' ||
    method === 'delete';
function queryString(params) {
    const qs = [];
    const encode = (key, value) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`;
    Object.keys(params).forEach((key) => {
        const value = params[key];
        if (value != null) {
            if (Array.isArray(value)) {
                value.forEach((value) => qs.push(encode(key, value)));
            }
            else {
                qs.push(encode(key, value));
            }
        }
    });
    if (qs.length > 0) {
        return `?${qs.join('&')}`;
    }
    return '';
}
function getPath(path, payload) {
    return path.replace(/\{([^}]+)\}/g, (_, key) => {
        const value = encodeURIComponent(payload[key]);
        delete payload[key];
        return value;
    });
}
function getQuery(method, payload, query) {
    let queryObj = {};
    if (sendBody(method)) {
        query.forEach((key) => {
            queryObj[key] = payload[key];
            delete payload[key];
        });
    }
    else {
        queryObj = Object.assign({}, payload);
    }
    return queryString(queryObj);
}
function getHeaders(body, init) {
    const headers = new Headers(init);
    if (body !== undefined &&
        !(body instanceof FormData) &&
        !headers.has('Content-Type')) {
        headers.append('Content-Type', 'application/json');
    }
    if (!headers.has('Accept')) {
        headers.append('Accept', 'application/json');
    }
    return headers;
}
function getBody(method, payload) {
    if (!sendBody(method)) {
        return;
    }
    const body = payload instanceof FormData ? payload : JSON.stringify(payload);
    return method === 'delete' && body === '{}' ? undefined : body;
}
function mergeRequestInit(first, second) {
    const headers = new Headers(first === null || first === void 0 ? void 0 : first.headers);
    const other = new Headers(second === null || second === void 0 ? void 0 : second.headers);
    for (const key of other.keys()) {
        const value = other.get(key);
        if (value != null) {
            headers.set(key, value);
        }
    }
    return Object.assign(Object.assign(Object.assign({}, first), second), { headers });
}
function getFetchParams(request) {
    var _a;
    const payload = Object.assign(Array.isArray(request.payload) ? [] : {}, request.payload);
    const path = getPath(request.path, payload);
    const query = getQuery(request.method, payload, request.queryParams);
    const body = getBody(request.method, payload);
    const headers = getHeaders(body, (_a = request.init) === null || _a === void 0 ? void 0 : _a.headers);
    const url = request.baseUrl + path + query;
    const init = Object.assign(Object.assign({}, request.init), { method: request.method.toUpperCase(), headers,
        body });
    return { url, init };
}
function getResponseData(response) {
    return __awaiter(this, void 0, void 0, function* () {
        const contentType = response.headers.get('content-type');
        if (response.status === 204) {
            return undefined;
        }
        if (contentType && contentType.indexOf('application/json') !== -1) {
            return yield response.json();
        }
        const text = yield response.text();
        try {
            return JSON.parse(text);
        }
        catch (e) {
            return text;
        }
    });
}
function fetchJson(url, init) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(url, init);
        const data = yield getResponseData(response);
        const result = {
            headers: response.headers,
            url: response.url,
            ok: response.ok,
            status: response.status,
            statusText: response.statusText,
            data,
        };
        if (result.ok) {
            return result;
        }
        throw new ApiError(result);
    });
}
function wrapMiddlewares(middlewares, fetch) {
    const handler = (index, url, init) => __awaiter(this, void 0, void 0, function* () {
        if (middlewares == null || index === middlewares.length) {
            return fetch(url, init);
        }
        const current = middlewares[index];
        return yield current(url, init, (nextUrl, nextInit) => handler(index + 1, nextUrl, nextInit));
    });
    return (url, init) => handler(0, url, init);
}
const preferNull = (maybe) => {
    if (maybe === undefined)
        return null;
    return maybe;
};
function fetchUrl(request) {
    return __awaiter(this, void 0, void 0, function* () {
        const _a = getFetchParams(request), _b = _a.init, { body } = _b, init = __rest(_b, ["body"]), { url } = _a;
        return (yield request.fetch(url, Object.assign(Object.assign({}, init), { body: preferNull(body) })));
    });
}
function createFetch(fetch) {
    const fun = (payload, init) => __awaiter(this, void 0, void 0, function* () {
        try {
            return yield fetch(payload, init);
        }
        catch (err) {
            if (err instanceof ApiError) {
                throw new fun.Error(err);
            }
            throw err;
        }
    });
    fun.Error = class extends ApiError {
        constructor(error) {
            super(error);
            Object.setPrototypeOf(this, new.target.prototype);
        }
        getActualType() {
            return {
                status: this.status,
                data: this.data,
            };
        }
    };
    return fun;
}
function fetcher() {
    let baseUrl = '';
    let defaultInit = {};
    const middlewares = [];
    const fetch = wrapMiddlewares(middlewares, fetchJson);
    return {
        configure: (config) => {
            baseUrl = config.baseUrl || '';
            defaultInit = config.init || {};
            middlewares.splice(0);
            middlewares.push(...(config.use || []));
        },
        use: (mw) => middlewares.push(mw),
        path: (path) => ({
            method: (method) => ({
                create: ((queryParams) => createFetch((payload, init) => fetchUrl({
                    baseUrl: baseUrl || '',
                    path: path,
                    method: method,
                    queryParams: Object.keys(queryParams || {}),
                    payload: payload || {},
                    init: mergeRequestInit(defaultInit, init),
                    fetch,
                }))),
            }),
        }),
    };
}
exports.Fetcher = {
    for: () => fetcher(),
};
function arrayRequestBody(array, params) {
    return Object.assign([...array], params);
}
exports.arrayRequestBody = arrayRequestBody;
class ApiError extends Error {
    constructor(response) {
        super(response.statusText);
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "statusText", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.setPrototypeOf(this, new.target.prototype);
        this.headers = response.headers;
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.data = response.data;
    }
}
exports.ApiError = ApiError;
